---
title: 'Hola Mundo! Y ahora, ¬øpor d√≥nde empiezo?'
description: '¬øQu√© lenguaje elegir? ¬øBackend, fronted o ambos? ¬øQu√© diferencias hay? Estas y otras muchas preguntas seguro que han pasado por tu cabeza si est√°s empezando en esto del software. En este post dar√© respuesta a algunas de las preguntas m√°s frecuentes y algunas pincelazas sobre temas relacionados.'
pubDate: 'Feb 23 2025'
---

¬øQu√© lenguaje elegir? ¬øBackend, fronted o ambos? ¬øQu√© diferencias hay? Estas y otras muchas preguntas seguro que han pasado por tu cabeza si est√°s empezando en esto del software. En este post dar√© respuesta a algunas de las preguntas m√°s frecuentes y algunas pincelazas sobre temas relacionados.

## Por d√≥nde empezar (seg√∫n los datos)

Es posible que si quieres empezar en el mundo del software, y andas algo perdido, lo primero que hagas sea preguntar a una IA para que te oriente un poco. Esto podr√≠a ser una buena estrategia y seguramente te ayude, as√≠ que te insto a que contrastes con ella lo que te voy a contar aqu√≠. Nosotros vamos a hacerlo a la manera tradicional: usando datos.

<a href="https://www.getmanfred.com" target="_blank">Manfred</a> es una empresa de recruiting bastante famosa a nivel espa√±ol y que tiene muy buena base de conocimiento para hablar de estos temas. Anualmente suelen hacer <a href="https://www.getmanfred.com/developer-career-report" target="_blank">un reporte sobre la distribuci√≥n de tecnolog√≠as seg√∫n demanda y rol</a>, entre otras cosas y se pueden sacar conclusiones muy interesantes. Ciertamente este reporte es de 2024, pero nos sirve. Por ejemplo, en la gr√°fica de <a href="https://www.getmanfred.com/es/developer-career-report#mostwantedroles" target="_blank">roles m√°s demandados</a>[]() se puede ver que los roles de **frontend** y **backend** se mantienen estables a lo largo del tiempo, **por lo que parece interesante centrarse en alguno de estos roles**. 

> Roles como ingenieros de datos o en Machine Learning han empezado a ganar much√≠simo peso en estos √∫ltimos a√±os. A√∫n as√≠, no voy a listarlos aqu√≠ ya que la ingenier√≠a de datos e inteligencia artificial son una rama distinta al desarrollo de software m√°s "tradicional" y las competencias necesarias son muy distintas.

## Pues ni Backend ni Frontend: ¬°ambos!
Si eres de los que has pensado que por qu√© elegir pudiendo aprenderlo todo te dir√© dos cosa. La primera: <mark>¬°Enhorabuena!</mark> **Las ganas de aprender son esenciales para dedicarte a esto** ya que te requerir√° mucho tiempo y esfuerzo mantenerte al d√≠a con las tecnolog√≠as y avances del sector. Ahora, la segunda. Como se suele decir: *"El que mucho abarca poco aprieta"*, al menos al principio y, sobre todo, en el contexto de una persona junior o sin experiencia. ¬øQuiere esto decir que debes elegir una y descartar tajantemente la otra? No, al contrario. Es m√°s, te insto a que pruebes y experimentes con todas las tecnolog√≠as que puedas, pero que **elijas una de sus vertientes y te hagas un experto en ella** *(y sobre todo que al principio dediques la mayor parte del esfuerzo en asentar las bases como comentar√© despu√©s)*. Esto no te lo recomiento por capricho sino porque, de nuevo, <a href="https://www.getmanfred.com/developer-career-report#rolesdistribution" target="_blank">remiti√©ndome a los datos</a>, para poder llegar a hacer lo que la mayor√≠a no hace *(perfiles Full-Stack, Software Architect, etc)* se requiere de mucho aprendizaje, s√≠, **pero tambi√©n de mucha experiencia**. 

> Tambi√©n, **y esto es experiencia personal**, los equipos de desarrollo suelen ser equipos multidisciplinares o mixtos, donde en cada equipo hay **una o varias personas desempe√±ando roles concretos**, y es menos com√∫n ver proyectos donde todos hacen de todo. De nuevo, s√≠ que existen proyectos de este tipo, por supuesto, pero a lo largo de los a√±os me los he encontrado en un porcentaje mucho menor.

## Pues lo tengo claro: elijo lo que me d√© m√°s dinero üí∏
Bueno... Aunque es totalmente l√≠cito basar la elecci√≥n en el dinero **no te lo recomendar√≠a**. ¬øPor qu√©? Porque normalmente aprender el lenguaje, la tecnolog√≠a o el framework de turno puede beneficiarte a corto plazo o medio plazo. Pero a la larga el problema es obvio: apuestas por una tecnolog√≠a que es muy relevante y demandada de la cual te beneficias hoy. Pero ma√±ana, por cualquier motivo, deja de ser relevante y las empresas dejan de demandar esos perfiles. Es por eso que uno de los mejores consejos que podr√≠a dar a una persona que va a empezar es **que comience por las bases**.

## Las bases ‚≠êÔ∏è

> Voy a asumir que partes de manejar con soltura **estructuras de control b√°sicas**: `if/else`, `switch`, `for` y `while` en cualquier lenguaje. Si los t√©rminos anteriores te suenan a hacker, o te suenan pero tampoco los has usado mucho, te recomendar√≠a que dejes de leer este post ahora mismo y que vayas a alguna de las p√°ginas que te dejo a continuaci√≥n para que practiques todo lo posible: <a href="https://codecombat.com/" target="_blank">Codecombat</a>, <a href="https://www.codewars.com/" target="_blank">Codewars</a>, <a href="https://adventofcode.com/" target="_blank">Adventofcode</a>. O pregunta a tu IA favorita por problemas b√°sicos de programaci√≥n e implem√©ntalos en el lenguaje de programaci√≥n que m√°s te llame.

En esta secci√≥n vamos a tocar "todos los palos". Todo lo que voy a citar aqu√≠ es lo **m√≠nimo indispensable que cualquier desarrollador de software debe conocer**, en mayor o menor medida y con mayor o menor soltura. Otro tema es la profundidad de dicho conocimiento, pero al menos **un conocimiento b√°sico de todos ellos es esencial**.

### El paradigma
Presta atenci√≥n <a href="https://www.getmanfred.com/es/developer-career-report#talentpertech" target="_blank">a esta gr√°fica</a>. ¬øQu√© dir√≠as que tienen en com√∫n esos lenguajes? M√°s del 50% de ellos son lenguajes de programaci√≥n **orientados a objetos** *(OOP para los amigos)*. La mayor√≠a de los lenguajes que el sector demanda suelen ser, en la gran mayor√≠a de los casos, lenguajes de este tipo, por lo que es clave manejar conceptos b√°sicos de este **paradigma de programaci√≥n: objetos, herencia, polimorfismo, abstracci√≥n, encapsulamiento, sobrecarga** y un largo etc. S√©, por experiencia propia, que la primera vez que se escuchan estas cosas se tiene un sentimiento de decepci√≥n, como que hay un oc√©ano de conocimiento que tienes que llenar "solo para empezar". Cr√©eme, el esfuerzo merecer√° la pena. Todo lo que aprendas cuando masterices esto **ser√° extrapolable a la mayor√≠a de lenguajes y tecnolog√≠as que uses**, ya que muchos de ellos est√°n bajo el paraguas de dicho paradigma, por lo que el retorno de inversi√≥n est√° m√°s que justificado. De ah√≠ que no importe tanto el lenguaje, sino c√≥mo de asentados tienes todos esos conocimientos. Un mismo dise√±o o problema se puede abordar usando la misma base independientemente de si el lenguaje es Java o JavaScript, backend o frontend, porque **la base es com√∫n**.

### Patrones de dise√±o
Aunque estas bases no est√°n pensadas como una lista ordenada per-s√©, s√≠ que hay una peque√±a "jerarqu√≠a" de aprendizaje donde, para poder avanzar al siguiente, deber√≠as tener bastante controlado el anterior. Y, por supuesto, tambi√©n hay temas ortogonales a otros que se pueden aprender en paralelo o sin necesidad de un orden espec√≠fico. En este caso, yo dir√≠a que **hay una dependencia entre** controlar sobre **los principios de orientaci√≥n a objetos y los patrones de dise√±o**. Dado que la piedra angular de la mayor√≠a de patrones son la herencia, la abstracci√≥n y encapsulamiento (entre otros) estos conceptos deben manejarse con mediana soltura. Dicho esto, patrones de dise√±o <a href="https://en.wikipedia.org/wiki/Software_design_pattern" target="_blank">hay un mont√≥n</a> y, si bien es cierto que todos son importantes y que merece mucho la pena tenerlos siempre en mente, hay algunos que son m√°s comunes de usar que otros. Voy a dar una lista de los que **a m√≠ me parecen esenciales**, pero no deja de ser criterio personal y basado en mi experiencia. Dicho esto, **los patrones de dise√±o que se tienen que conocer m√≠nimamente** y tener una imagen clara en la mente de la jerarqu√≠a de interfaces, implementaciones y sus conexiones ser√≠an: 

* Factory *(no incluir√≠a factor√≠a abstracta)*
* Builder
* Singleton
* Decorator
* Command
* Chain of Responsibility
* State
* Strategy 
* Template
* Iterator

### Estructuras de datos y algoritmos (en adelante DSA)

Bueno, aqu√≠ llegamos al apartado que, en mi opini√≥n, es el m√°s importante de todos. Es m√°s, dir√≠a que **las estructuras de datos y los algoritmos son la base de la base**. Y, parad√≥jicamente, son a la vez, lo que m√°s se desconoce y lo que menos se practica *(supongo que porque la curva de aprendizaje es muy pronunciada)*. Lamentablemente este punto es tan sumamente grande que, no es que no se pueda contar en este p√°rrafo o en esta entrada, es que necesitar√≠a un blog completo para hablar **exclusivamente** de esto con suficiente rigor.

Por suerte hay buenas noticias. Siempre **puedes quedarte con una visi√≥n m√°s pragm√°tica** de este tema, conoci√©ndolo un poco por encima y sin entrar en mucha profundidad. **¬øEs esto suficiente?** Pues como siempre: **depende**. Pero dado que este post est√° pensado para personas que quieren empezar quiz√°s s√≠ lo es. Por tanto, puede estar justificado tener una vista de √°guila de los conceptos y algoritmos esenciales **en primera instancia** y, a medida que se vaya ganando experiencia y madurando, ahondar todo lo posible. 

> **Fun** *(o no tan fun)* **fact**
> 
> Cuando comenc√© mi carrera profesional, empec√© a interesarme *(y a necesitar)* conocer m√°s sobre DSA. Al ser un mundo tan amplio y complejo, pregunt√© a algunos compa√±eros de trabajo cuestiones sobre c√≥mo medir y optimizar algoritmos, ya que algunos de ellos hab√≠an estudiado en la universidad *(yo nunca fui, aunque eso es otro tema)*. Supuse que deb√≠an conocer estos temas muy bien. Recuerdo que uno de ellos me dijo: *"no hace falta que estudies la complejidad de los algoritmos, ya te lo resumo yo: lo importante es evitar los bucles, s√≥lo eso"*. En aquel entonces no ten√≠a demasiado criterio para dudar de lo que me dijo *(aunque ya ah√≠ ten√≠a serias dudas)* pero esa frase se me qued√≥ marcada y, desde hace mucho, s√© cu√°n equivocada, reducida a lo absurdo y simplista fue esa respuesta. Por suerte no hice caso y te dir√≠a que, en general,  cuestiones y contrastes la informaci√≥n de algo que no controlas.

Entonces, **¬øpor d√≥nde empezamos?** Como he dicho, es un mundo muy amplio pero s√≠ que hay algunos puntos por los que se podr√≠a empezar, entendiendo el algoritmo, su funcionamiento e implementaci√≥n, sin entrar a hacer an√°lisis de complejidad de los mismos.

#### Algoritmos

Dentro del vasto oc√©ano de algoritmos famosos que existen, yo empezar√≠a por **algoritmos de ordenaci√≥n**. En mi opini√≥n son los m√°s f√°ciles de entender y de implementar *(mi primera ""implementaci√≥n"" fue usando una baraja de cartas)*. Pecando de simplista, dir√≠a que los m√°s interesantes a conocer por su diversidad de implementaci√≥n ser√≠an:

* Insertion sort
* Selection sort
* Merge sort
* Heap sort
* Quick sort

Con esa lista, m√≠nimo, te aseguras de entender algo de **recursividad**, **matrices**, un poco de **√°rboles binarios** y, con suerte, empezar√° a sonarte algo de la **notaci√≥n big-O**. Una vez vistos los algoritmos de ordenaci√≥n pasar√≠a a los **algoritmos de b√∫squeda**, tambi√©n muy √∫tiles:

* Linear search
* Binary search *(√©ste, adem√°s de ser muy f√°cil de entender e implementar, es muy eficiente)*
* Depth-First Search
* Breadth-First Search

#### Estructuras de datos

Pasando a un segundo gran bloque tendr√≠amos **estructuras de datos**, que son elementos que nos sirven para trabajar con datos *(seguro que no te lo esperabas)* de forma eficiente. Todos tienen pros y contras respecto a los dem√°s, y justo es interesante estudiarlos para saber cu√°l usar dependiendo de la necesidad.

* Arrays, Stacks y Queues *(los agrupo por similitud aunque realmente son estructuras distintas)*
* Linked Lists
* Hash Tables
* Grafos y √°rboles

Cierro este apartado comentando que, efectivamente, **es mucha tela que cortar**. Pero entender e implementar cada uno de los algoritmos y estructuras de datos mencionados por uno mismo **vale oro**, al menos una vez.

> **DSA's en el d√≠a a d√≠a**
> 
> La mayor√≠a de los lenguajes de programaci√≥n *(y no digo todos por si hay alguno especialito)* tienen su propia implementaci√≥n de la mayor√≠a de algoritmos y estructuras de datos que en este apartado se mencionan. Si te pica la curiosidad, coge tu lenguaje favorito e inf√≥rmate sobre cu√°ntos de los anteriores implementa. E incluso, si te engancha el tema, puedes echar un vistazo a c√≥mo est√°n implementados!

### SQL y sistemas de bases de datos

**Con lo que llevamos hasta ahora**, conseguir√≠amos desarrollar el software necesario para cubrir una funcionalidad dada, utilizando para ello un **dise√±o y estructura del c√≥digo √≥ptimos**, permiti√©ndonos iterarlo de forma efectiva con el tiempo. Tambi√©n sabriamos **identificar c√≥mo de eficiente es el c√≥digo que hemos escrito** a la hora de trabajar con un gran volumen de datos. Y eso est√° genial pero, ¬øde d√≥nde sacamos esos datos? 

Otro gran bloque que es esencial conocer y dominar para cualquier desarrollador que se precie, son los sistemas de bases de datos (RDBMS) y c√≥mo interactuar con ellos. Tipos de bases de datos tambi√©n hay un mont√≥n *(esto tampoco te lo ve√≠as venir, eh* üòâ *)*. Siguiendo con el <a href="https://asana.com/es/resources/pareto-principle-80-20-rule" target="_blank">principio de Pareto</a>, como venimos haciendo hasta ahora, **lo m√°s √∫til ser√≠a aprender bases de datos relacionales**, que es algo que **seguro vas a usar en el 90% de los proyectos a los que te enfrentes**.

Cada vendor de base de datos tiene sus particularidades en cuanto a funcionalidades, configuraci√≥n, logs, etc. Por tanto vamos a centrarnos en el contenido que s√≠ que es com√∫n a todas y que es necesario conocer:

#### RDMBS
Qu√© son y qu√© elementos componen a las **RDBMS** (**R**elational **D**atabase **M**anagement **S**ystem)

* Esquemas, tablas, columnas, filas, atributos y tipos
* Claves primarias y for√°neas
* Relaciones
* Restricciones
* Transaccionabilidad
* Indexaci√≥n
* Normalizaci√≥n y formas normales

#### SQL

Por √∫ltimo, una vez conoces c√≥mo almacenar datos necesitas alg√∫n mecanismo para trabajar con ellos. **SQL** al rescate! SQL (**S**tructured **Q**uery **L**anguage) es un lenguaje **est√°ndar** que nos permite hablar con cualquier motor de base de datos que se acoja a dicho est√°ndar *(que ya os adelanto que son muchos. Much√≠simos!)*. Es un lenguaje **declarativo** donde b√°sicamente dices qu√© quieres hacer pero no c√≥mo. De eso se encarga el propio motor.

A su vez, motores de bases de datos relacionales hay much√≠simos y aqu√≠ s√≠ que da un poco igual cu√°l escojas. Si tienes alguno de preferencia porque est√© de moda; adelante. Yo comenc√© usando **MySQL** porque era el motor "de moda" en mi √©poca. Hoy d√≠a (y en aquel entonces tambi√©n) hay muchas alternativas. Voy a listar unas cuantas pero, me reitero, puedes elegir el que m√°s te guste:

* PostgreSQL
* MySQL
* MariaDB
* SQLite
* H2 $^*$

> $*$ H2 no es un motor de bases de datos "tradicional" sino una implementaci√≥n de motor de base de datos **en memoria**. Muy √∫til para hacer pruebas en local de forma r√°pida. Adem√°s te comunicas usando SQL siendo una buena alternativa para empezar.

**Si has llegado hasta aqu√≠ ¬°enhorabuena!** Lo que resta aunque sigue siendo muy importante, ocupar√≠a una posici√≥n inferior en una lista de cosas prioritarias. ¬°Ojo! No estoy diciendo que no tengas que conocerlo, solo digo que "al C√©sar lo que es del C√©sar". 

### Herramientas de versi√≥n de control
Normalmente las primeras l√≠neas de c√≥digo que tiramos las escribimos solos, en un ambiente controlado, donde al retormar lo que hiciste ayer sigue estando tal y como lo dejaste. Esto, como podr√°s imaginar, **dista mucho de lo que te puedes encontrar en un entorno colaborativo**. El tema es que el c√≥digo que normalmente escribes cuando no est√°s t√∫ solo en el proyecto es **din√°mico** y otras personas pueden participar dentro de la misma base de c√≥digo que est√°s tocando t√∫. Para tener un registro vivo de todo lo que ha ocurrido en el proyecto, tener un control de qu√© persona ha hecho qu√© y cu√°ndo, por qu√© lo hizo, a qu√© hora, etc. Es necesario usar (y saber usar) un **sistema de control de versiones**. Aqu√≠ no voy a deciros que hay una lista inmensa y ni nada de eso. Aqu√≠ el rey es el rey: **Git**.

*"[Git](https://git-scm.com/) es un sistema de control de versiones distribuido que permite gestionar y hacer un seguimiento de los cambios en el c√≥digo fuente de un proyecto, facilitando la colaboraci√≥n entre desarrolladores."* - by Chatgpt. Cortita y al pie; no hay mucho m√°s que a√±adir. 

Si aspiras a dedicarte a esto o lo haces por hobbie; **aprende Git**. Pero no aprender a usarlo a trav√©s de interfaces gr√°ficas que no sabes muy bien qu√© o c√≥mo hacen lo que hacen, sino **usando la terminal, a puro comando**. Una vez asentadas las bases y sabiendo lo que hay "under the hood" entonces, si lo veis necesario, pasad a usar una interfaz de usuario.

### Testing
Normalmente las primeras l√≠neas de c√≥digo que tiramos las escribimos solos, en un ambiente controlado donde al retormar lo que hiciste ayer sigue estando tal y como lo dejaste. No, no se me ha escapado el usar la misma frase que en el p√°rrafo anterior. Aqu√≠ el contexto es el mismo: cuando trabajas solo o en un proyecto sin mucha repercusi√≥n quiz√° esto no te interese. Pero si tu objetivo es trabajar con otras personas o hacer **software de calidad** esto es indiscutible.

Saber hacer testing es necesario, puesto que a medida que iteras y evolucionas tu c√≥digo necesitas **cerciorarte** de que lo una vez hiciste y dejaste funcionando, a d√≠a de hoy y despu√©s de todos los cambios que el ciclo de vida del proyecto haya requerido, **sigue funcionando exactamente igual**. Si ya has elegido lenguaje o est√°s buscando candidato para aprender, √©chale un ojo *al internet* porque seguro que de una forma u otra puedes hacer testing con ese lenguaje.

De entre <a href="https://www.atlassian.com/continuous-delivery/software-testing/types-of-software-testing" target="_blank">todos los tipos de tests que hay</a>, el que yo os recomendar√≠a para ir empezando es hacer <a href="https://en.wikipedia.org/wiki/Unit_testing" target="_blank">testing unitario</a>.

## Un largo (y apasionante) etc√©tera

Probablemente si has llegado a este punto, estar√°s pensando que c√≥mo es posible que diga que hay tant√≠simo contenido esencial, solo para empezar, cuando hay por ah√≠ cursos y bootcamps que prometen convertirte en un desarrollador listo para el mundo laboral, de zero-to-hero üöÄ, en meses o semanas (algunos incluso en horas ü•≤). Parad√≥jicamente, yo me hago la misma pregunta. Reitero lo que dec√≠a al principio: **cuestiona y contrasta** todo lo que te digan o leas. **Prueba**, es gratis! (casi siempre ü§£). **Saca tus propias conclusiones**. S√© cr√≠tico. **Si algo es demasiado bonito para ser cierto, ya sabes... Probablemente lo sea**.

Voy a dejar como referencia esta p√°gina: <a href="https://roadmap.sh/" target="_blank">https://roadmap.sh</a>. Me parece s√∫per interesante ya que, de forma colaborativa, se est√°n construyendo distintas hojas de ruta en base a distintas tecnolog√≠as trav√©s de las cuales te puedes ir abriendo camino entre tanto follaje tecnol√≥gico.

**Mi idea es ir creando una serie de entradas en el blog hablando detalladamente de cada uno de los puntos que aqu√≠ se tratan y de muchos m√°s**. Mientras tanto, en la secci√≥n de [Recursos](/resources) voy a dejar enlaces a cursos, charlas y, en general, contenido que a mi me ha resultado √∫til o de inter√©s. Como comento en la secci√≥n donde [hablo de m√≠](/about-me), **uno de los motivos por los que hago este blog es para poder contar aquellas cosas que me hubiera encantado que me contaran cuando yo empec√©**. Cualquier duda, comentario, correcci√≥n o cr√≠tica, tienes mi correo justo en el footer. 

![see you](https://media2.giphy.com/media/v1.Y2lkPTc5MGI3NjExZGhmbmRiMG1qZnhub2x1czhwaDNkamt0ZnZ5NDBpbTd0aWU1cXloOSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/kaBU6pgv0OsPHz2yxy/giphy.gif#center)
